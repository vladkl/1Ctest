///////////////////////////////////////////////////////////////////////////////
// ОБРАБОТКА ИСХОДНЫХ ДАННЫХ

// Загрузить структуру хранения метаданных исследуемой информационной базы
// для последующего анализа
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер, во время которого существовали метаданные
//  Местоположение - Строка, имя файла со структурой хранения ИБ или
//                 Неопределено для получения структуры подключенной ИБ
//
Процедура ЗагрузитьСтруктуруМетаданных(ДокументЗамер) Экспорт
	
	Набор = РегистрыСведений.ДанныеМетаданных.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументЗамер);
	
	НачатьТранзакцию();
	Блокировка = Новый БлокировкаДанных;
	СтрокаБлокировки = Блокировка.Добавить("РегистрСведений.ДанныеМетаданных");
	СтрокаБлокировки.УстановитьЗначение("Владелец", ДокументЗамер);
	СтрокаБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	//Блокировка.Заблокировать();
	
	СтрокаНабора = Набор.Добавить();
	СтрокаНабора.Период = ДокументЗамер.Дата;
	СтрокаНабора.Владелец = ДокументЗамер;
	
	Подключение = ИнформационнаяБаза.ПодключениеИБ(ДокументЗамер.ИнформационнаяБаза);
	СоединениеИБ = ИнформационнаяБаза.СоединениеИБ(Подключение);
	
	ПолнаяСтруктура = СтруктураМетаданных.ПолучитьСтруктуруХранения(СоединениеИБ, Истина);
	СтруктураВТаблице = СтруктураМетаданных.СтруктураБазыИзComВТаблицуЗначений(ПолнаяСтруктура);
	СтрокаНабора.СУБД = Новый ХранилищеЗначения(СтруктураВТаблице, Новый СжатиеДанных(9));
	
	ПолнаяСтруктура = СтруктураМетаданных.ПолучитьСтруктуруХранения(СоединениеИБ, Ложь);
	СтруктураВТаблице = СтруктураМетаданных.СтруктураБазыИзComВТаблицуЗначений(ПолнаяСтруктура);
	СтрокаНабора.Sdbl = Новый ХранилищеЗначения(СтруктураВТаблице, Новый СжатиеДанных(9));
	
	Набор.Записать(Истина);
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ЗагрузитьСтруктуруМетаданных()

// Загрузить каталоги технологического журнала в регистр
// для последующего анализа
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер, во время которого снимался ТЖ
//
Процедура ЗагрузитьТЖ(ДокументЗамер) Экспорт
	
	ЗагрузитьДанныеВРегистр(
		ДокументЗамер,
		РегистрыСведений.ДанныеТЖ,
		ДокументЗамер.МестоположениеТЖ,
		"ПоместитьКаталогВРегистр");
		
КонецПроцедуры // ЗагрузитьТЖ()

// Загрузить графы взаимоблокировок из файлов трассировки в регистр
//
// Параметры:
//  ФайлыТрассировок - Строка
//  ДокументЗамер - ДокументСсылка.Замер
//
Процедура ЗагрузитьГрафыВзаимоблокировок(ДокументЗамер) Экспорт
	
	// Подключиться к серверу СУБД
	ПодключениеСУБД = КипВнешнийКомпонент.ПолучитьMSSQL();
	MSSQL.ПодключитьMSSQL(ПодключениеСУБД, ДокументЗамер.ИнформационнаяБаза);
	
	// Очистить регистр графов взаимоблокировок
	Набор = РегистрыСведений.ГрафыВзаимоблокировок.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументЗамер);
	Набор.Записать();
	
	// Создать описание трассировки
	Для Каждого СтрокаМестоположения Из ДокументЗамер.МестоположениеТрассировки Цикл
		
		Трассировка = MSSQL.СоздатьСтруктуруТрассировки();
		Трассировка.ИмяСервераСУБД = ДокументЗамер.СерверСУБД;
		Трассировка.ПолноеИмяФайла = СтрокаМестоположения.Путь;
		Трассировка.ИменаКолонок = MSSQL.СписокКолонокВИменаКолонок("SPID, StartTime, TextData, EventSequence");
		Трассировка.ИнформационнаяБаза = ДокументЗамер.ИнформационнаяБаза;
		
		// Поместить графы взаимоблокировок в регистр
		НомерПоследнегоСобытия = Неопределено;
		
		Пока Истина Цикл
			ПорцияСобытий = MSSQL.ПолучитьПорциюСобытий(НомерПоследнегоСобытия, 100, Трассировка);
			
			Если ПорцияСобытий.Количество() = 0 Тогда
				Прервать;
			КонецЕсли;
			
			НачатьТранзакцию();
			Блокировка = Новый БлокировкаДанных;
			СтрокаБлокировки = Блокировка.Добавить("РегистрСведений.ГрафыВзаимоблокировок");
			СтрокаБлокировки.УстановитьЗначение("Владелец", ДокументЗамер);
			СтрокаБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			//Блокировка.Заблокировать();
			
			Набор.Очистить();
			
			Для Каждого СтрокаПорцииСобытий Из ПорцияСобытий Цикл
				
				// Пропуск "испорченных" SQL Server'ом графов взаимоблокировок
				Попытка
					ОбщегоНазначенияКлиентСервер.ПолучитьDOMИзСтрокиXML(СтрокаПорцииСобытий.TextData);
				Исключение
					Продолжить;
				КонецПопытки;
				
				СтрокаНабора = Набор.Добавить();
				СтрокаНабора.Номер = Число(СтрокаПорцииСобытий.EventSequence);
				СтрокаНабора.Период = ДокументЗамер.Дата;
				СтрокаНабора.Граф = СтрокаПорцииСобытий.TextData;
				СтрокаНабора.ДатаСобытия = MSSQL.ВремяMSSQLВоВремя1С(СтрокаПорцииСобытий.StartTime);
				СтрокаНабора.МоментВремениСобытия = MSSQL.ВремяMSSQLВТики(СтрокаПорцииСобытий.StartTime);
				СтрокаНабора.Владелец = ДокументЗамер;
			КонецЦикла;
			
			Набор.Записать(Ложь);
			ЗафиксироватьТранзакцию();
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьГрафыВзаимоблокировок()

// Загрузить данные из файлов трассировки в регистр
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер
//
Процедура ЗагрузитьДанныеТрассировки(ДокументЗамер) Экспорт
	
	// Подключиться к серверу СУБД
	ПодключениеСУБД = КипВнешнийКомпонент.ПолучитьMSSQL();
	MSSQL.ПодключитьMSSQL(ПодключениеСУБД, ДокументЗамер.ИнформационнаяБаза);
	
	// Очистить регистр с данными трассировок
	Набор = РегистрыСведений.ДанныеТрассировок.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументЗамер);
	Набор.Записать();
	
	ТаблицыИсключения = Новый Массив;
	ТаблицыИсключения.Добавить("_YearOffset");
	
	СмещениеВремениСУБД = (ДокументЗамер.Дата-ДокументЗамер.ДатаНаСервереСУБД);
	СмещениеВремениСУБДВТиках = СмещениеВремениСУБД * 10000000;
	
	// Создать описание трассировки
	Для Каждого СтрокаМестоположения Из ДокументЗамер.МестоположениеТрассировки Цикл
		
		Трассировка = MSSQL.СоздатьСтруктуруТрассировки();
		Трассировка.ИмяСервераСУБД = ДокументЗамер.СерверСУБД;
		Трассировка.ПолноеИмяФайла = СтрокаМестоположения.Путь;
		Трассировка.ИменаКолонок = MSSQL.СписокКолонокВИменаКолонок("SPID, EventClass, TransactionID, EventSequence, StartTime, EndTime, TextData, ObjectID, ObjectID2, Type, Mode");
		Трассировка.ИнформационнаяБаза = ДокументЗамер.ИнформационнаяБаза;
		
		// Поместить данные в регистр
		НомерПоследнегоСобытия = Неопределено;
		
		Пока Истина Цикл
			ПорцияСобытий = MSSQL.ПолучитьПорциюСобытий(НомерПоследнегоСобытия, 100000, Трассировка);
			
			Если ПорцияСобытий.Количество() = 0 Тогда
				Прервать;
			КонецЕсли;
			
			НачатьТранзакцию();
			Блокировка = Новый БлокировкаДанных;
			СтрокаБлокировки = Блокировка.Добавить("РегистрСведений.ДанныеТрассировок");
			СтрокаБлокировки.УстановитьЗначение("Владелец", ДокументЗамер);
			СтрокаБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			//Блокировка.Заблокировать();
			
			Набор.Очистить();
			
			Для Каждого СтрокаПорцииСобытий Из ПорцияСобытий Цикл
				
				Если Не ЗначениеЗаполнено(СтрокаПорцииСобытий.TransactionID)
						Или СтрокаПорцииСобытий.TransactionID = "0" Тогда
					Продолжить;
				КонецЕсли;
				
				// Для сокращения объема информации исключить блокировки служебных таблиц, 
				// например "Files", "_YearOffset" и подобных
				Если СтрокаПорцииСобытий.EventClass = "24" Или СтрокаПорцииСобытий.EventClass = "60" Тогда
					ОписаниеТаблицы = MSSQLПовтИсп.ПолучитьОписаниеОбъектаПоObjectID(
						ДокументЗамер.ИнформационнаяБаза,
						СтрокаПорцииСобытий.ObjectID,
						СтрокаПорцииСобытий.ObjectID2
					);
					Если Не СтрНачинаетсяС(ОписаниеТаблицы.ИмяТаблицы, "_") Тогда
						Продолжить;
					ИначеЕсли ТаблицыИсключения.Найти(ОписаниеТаблицы.ИмяТаблицы) <> Неопределено Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				
				СтрокаНабора = Набор.Добавить();
				СтрокаНабора.SPID = Число(СтрокаПорцииСобытий.SPID);
				СтрокаНабора.EventClass = Число(СтрокаПорцииСобытий.EventClass);
				СтрокаНабора.EventSequence = Число(СтрокаПорцииСобытий.EventSequence);
				СтрокаНабора.Владелец = ДокументЗамер;
				СтрокаНабора.Период = ДокументЗамер.Дата;
				
				СтрокаНабора.TransactionID = Число(СтрокаПорцииСобытий.TransactionID);
				СтрокаНабора.ДатаНачалаСобытия = MSSQL.ВремяMSSQLВоВремя1С(СтрокаПорцииСобытий.StartTime) + СмещениеВремениСУБД;
				СтрокаНабора.МоментВремениНачалаСобытия = MSSQL.ВремяMSSQLВТики(СтрокаПорцииСобытий.StartTime) + СмещениеВремениСУБДВТиках;
				СтрокаНабора.TextData = СтрокаПорцииСобытий.TextData;
				
				Если СтрокаНабора.EventClass = 24 Или СтрокаНабора.EventClass = 60 Тогда
					СтрокаНабора.ObjectName = ОписаниеТаблицы.ИмяТаблицы;
					СтрокаНабора.IndexName = ОписаниеТаблицы.ИмяИндекса;
					СтрокаНабора.ObjectType = Число(ОписаниеТаблицы.ТипОбъекта);
					СтрокаНабора.Type = Число(СтрокаПорцииСобытий.Type);
					СтрокаНабора.Mode = Число(СтрокаПорцииСобытий.Mode);
				Иначе
					// EventClass = 10 Или EventClass = 12
					СтрокаНабора.ДатаОкончанияСобытия = MSSQL.ВремяMSSQLВоВремя1С(СтрокаПорцииСобытий.EndTime) + СмещениеВремениСУБД;
					СтрокаНабора.МоментВремениОкончанияСобытия = MSSQL.ВремяMSSQLВТики(СтрокаПорцииСобытий.EndTime) + СмещениеВремениСУБДВТиках;
				КонецЕсли;
				
				Если СтрокаНабора.EventClass = 10 Тогда
					ТекстЗапроса = СтрокаПорцииСобытий.TextData;
					Если СтрНачинаетсяС(ТекстЗапроса, "exec sp_executesql N'") Тогда
						ТекстЗапроса = Сред(ТекстЗапроса, 22);
					КонецЕсли;
					НачалоБлокаПараметров = СтрНайти(ТекстЗапроса, "',N'@P1 ");
					Если НачалоБлокаПараметров > 0 Тогда
						ТекстЗапроса = Лев(ТекстЗапроса, НачалоБлокаПараметров-1);
					КонецЕсли;
					ТекстЗапроса = MSSQL.ПолучитьТекстЗапросаСПараметрамиВопросами(ТекстЗапроса);
					ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "''", "'");
					СтрокаНабора.ТекстЗапроса = ТекстЗапроса;
				КонецЕсли;
			КонецЦикла;
			
			Набор.Записать(Ложь);
			ЗафиксироватьТранзакцию();
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьДанныеТрассировки()

// Получение исходных данных
//
Процедура ЗаданиеПолучитьИсходныеДанные(ДокументЗамер) Экспорт
	
	Попытка
		ПолучитьИсходныеДанные(ДокументЗамер);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		Замер.ЗаданиеНеВыполнено(ДокументЗамер, ИнформацияОбОшибке.Описание + ":"
			+ Символы.ПС + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		ОтладкаКлиентСервер.Ошибка(ИнформацияОбОшибке);
	КонецПопытки;
	
КонецПроцедуры // ЗаданиеПолучитьИсходныеДанные()

// Получение исходных данных
//
Процедура ПолучитьИсходныеДанные(ДокументЗамер)
	
	// Убедиться в доступности файлов ТЖ
	Для Каждого СтрокаПути Из ДокументЗамер.МестоположениеТЖ Цикл
		ОбщегоНазначения.ПроверитьДоступностьТЖ(СтрокаПути.Путь);
	КонецЦикла;
	Для Каждого СтрокаПути Из ДокументЗамер.МестоположениеТЖ Цикл
		ОбщегоНазначения.ПроверитьДоступностьТЖ(СтрокаПути.Путь);
	КонецЦикла;
	
	Если Не ДокументЗамер.Отменен Тогда
		ЗагрузитьСтруктуруМетаданных(ДокументЗамер);
		ЗагрузитьТЖ(ДокументЗамер);
	
		Если ДокументЗамер.Показатель = Справочники.Показатели.АнализВзаимоблокировок Тогда
			ЗагрузитьГрафыВзаимоблокировок(ДокументЗамер);
		ИначеЕсли ДокументЗамер.Показатель = Справочники.Показатели.АнализОжиданийНаБлокировках
			И ДокументЗамер.ИнформационнаяБаза.ИспользоватьППАнализГранулярностиБлокировок Тогда
			ЗагрузитьДанныеТрассировки(ДокументЗамер);
		КонецЕсли;
	КонецЕсли;
	
	Если Не Константы.НеУдалятьСлужебныеДанные.Получить() Тогда
		
		// Удалить файлы ТЖ, при необходимости
		Для Каждого СтрокаПути Из ДокументЗамер.МестоположениеТЖ Цикл
			Попытка
				УдалитьФайлы(СтрокаПути.Путь);
			Исключение
				Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗаписьЖурналаРегистрации("Ошибка удаления файла", УровеньЖурналаРегистрации.Предупреждение,,,Комментарий);
			КонецПопытки;
		КонецЦикла;
		
		// Удалить файлы трассировок, при необходимости
		Для Каждого СтрокаПути Из ДокументЗамер.МестоположениеТрассировки Цикл
			Попытка
				УдалитьФайлы(СтрокаПути.Путь);
			Исключение
				Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗаписьЖурналаРегистрации("Ошибка удаления файла", УровеньЖурналаРегистрации.Предупреждение,,,Комментарий);
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	Если ДокументЗамер.Отменен Тогда
		Замер.Удалить(ДокументЗамер);
	КонецЕсли;
	
	Замер.ИсходныеДанныеПолучены(ДокументЗамер);
	
КонецПроцедуры // ПолучитьИсходныеДанные()

// Загрузить данные в регистр
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер, во время которого снимался ТЖ
//  Регистр - Регистр, в который загружаются данные
//  Местоположения - ТаблицаЗначений, содержащая пути для загрузки
//  Обработчик - Строка, имя функции загрузки данных
//
Процедура ЗагрузитьДанныеВРегистр(ДокументЗамер, Регистр, Местоположения, Обработчик)
	
	Набор = Регистр.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументЗамер);
	
	//НачатьТранзакцию();
	Блокировка = Новый БлокировкаДанных;
	СтрокаБлокировки = Блокировка.Добавить("РегистрСведений." + Набор.Метаданные().Имя);
	СтрокаБлокировки.УстановитьЗначение("Владелец", ДокументЗамер);
	СтрокаБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	//Блокировка.Заблокировать();
	
	Набор.Записать();
	Данные = Новый Структура;
	Данные.Вставить("Набор", Набор);
	Данные.Вставить("НомерПути");
	Данные.Вставить("Период", ДокументЗамер.Дата);
	Данные.Вставить("Регистратор", ДокументЗамер);
	
	Для Каждого СтрокаМестоположения Из Местоположения Цикл
		НомерПути = Местоположения.Индекс(СтрокаМестоположения);
		Данные.НомерПути = НомерПути;
		Выполнить Обработчик + "(СтрокаМестоположения.Путь, Данные)";
	КонецЦикла;
	
	//ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ЗагрузитьДанныеВРегистр()

// Поместить файл в регистр порциями
//
// Параметры:
//  Путь - Строка, путь к загружаемому каталогу
//  Данные - Произвольный, служебная информация обработчика записи каталога в регистр
//
Процедура ПоместитьКаталогВРегистр(Путь, Данные)
	
	ОбработкаФайлов.ПрочитатьКаталогПорциями(
		Путь,
		"*",
		"Анализ.ПоместитьПорциюФайлаВРегистр",
		Данные);
	
КонецПроцедуры // ПоместитьКаталогВРегистр()

// Поместить файл в регистр порциями
//
// Параметры:
//  Порция - ХранилищеЗначений, сжатые двоичные данные блока файла
//  НомерПорции - Число, порядковый номер порции файла
//  Путь - Строка, путь к загружаемому файлу
//  Данные - Произвольный, служебная информация обработчика записи каталога в регистр
//
Процедура ПоместитьПорциюФайлаВРегистр(Порция, НомерПорции, Путь, Данные) Экспорт
	
	Набор = Данные.Набор;
	СтрокаНабора = Набор.Добавить();
	СтрокаНабора.Период = Данные.Период;
	СтрокаНабора.Путь = Путь;
	СтрокаНабора.НомерПути = Данные.НомерПути;
	СтрокаНабора.НомерПорции = НомерПорции;
	СтрокаНабора.Данные = Порция;
	СтрокаНабора.Владелец = Данные.Регистратор;
	Набор.Записать(Ложь);
	
КонецПроцедуры // ПоместитьПорциюФайлаВРегистр()

// Выгрузить технологический журнал во временный каталог на диске
// для последующей обработки
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер, владелец данных замера
//  Путь - Строка, место выгрузки, если Неопределено, то временный каталог
//
// Возвращаемое значение:
//  Массив - пути на диске, где лежит выгруженный технологический журнал
//
Функция ВыгрузитьТЖ(ДокументЗамер, Путь = Неопределено) Экспорт
	
	Возврат ВыгрузитьДанные(ДокументЗамер, "ДанныеТЖ", Ложь, Путь);
	
КонецФункции // ВыгрузитьТЖ()

// Выгрузить данные из регистра
//
// Параметры:
//  ИмяРегистраДанных - Строка, имя регистра, содержащего данные для выгрузки
//  ДетализированныеПути - Булево, Истина - создать список с именем каждого
//                 выгруженного файла, Ложь - создать список с именами
//                 каталогов групп выгруженных файлов
//  Путь - Строка, место выгрузки, если Неопределено, то временный каталог
//
// Возвращаемое значение:
//  Массив - пути на диске, где лежат выгруженные данные
//
Функция ВыгрузитьДанные(ДокументЗамер, ИмяРегистраДанных, ДетализированныеПути, Путь = Неопределено)
	
	ВременныйКаталог = ?(Путь = Неопределено, КаталогВременныхФайлов(), Путь) + Строка(Новый УникальныйИдентификатор);
	Пути = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДокументЗамер", ДокументЗамер);
	Запрос.УстановитьПараметр("Период", ДокументЗамер.Дата);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Хранилище.НомерПути,
		|	Хранилище.Путь,
		|	Хранилище.НомерПорции,
		|	Границы.МаксНомерПорции КАК МаксНомерПорции
		|ИЗ
		|	РегистрСведений." + ИмяРегистраДанных + " КАК Хранилище
		|	ЛЕВОЕ СОЕДИНЕНИЕ (
		|		ВЫБРАТЬ
		|			Хранилище.НомерПути,
		|			Хранилище.Путь,
		|			МАКСИМУМ(Хранилище.НомерПорции) КАК МаксНомерПорции
		|		ИЗ
		|			РегистрСведений." + ИмяРегистраДанных + " КАК Хранилище
		|		ГДЕ
		|			Хранилище.Период = &Период И
		|			Хранилище.Регистратор = &ДокументЗамер
		|		СГРУППИРОВАТЬ ПО
		|			Хранилище.НомерПути,
		|			Хранилище.Путь) КАК Границы
		|	ПО Хранилище.Путь = Границы.Путь
		|ГДЕ
		|	Хранилище.Период = &Период И
		|	Хранилище.Регистратор = &ДокументЗамер
		|УПОРЯДОЧИТЬ ПО
		|	Хранилище.НомерПути,
		|	Хранилище.Путь,
		|	Хранилище.НомерПорции
		|ИТОГИ ПО
		|	Хранилище.НомерПути,
		|	Хранилище.Путь";
	ВыборкаНомеровПутей = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	ЗапросДанных = Новый Запрос;
	ЗапросДанных.УстановитьПараметр("ДокументЗамер", ДокументЗамер);
	ЗапросДанных.УстановитьПараметр("Период", ДокументЗамер.Дата);
	ЗапросДанных.Текст = "
		|ВЫБРАТЬ
		|	Хранилище.Данные
		|ИЗ
		|	РегистрСведений." + ИмяРегистраДанных + " КАК Хранилище
		|ГДЕ
		|	Хранилище.Период = &Период И
		|	Хранилище.Регистратор = &ДокументЗамер И
		|	Хранилище.Путь = &Путь И
		|	Хранилище.НомерПорции = &НомерПорции";
	
	Пока ВыборкаНомеровПутей.Следующий() Цикл
		ВыборкаПутей = ВыборкаНомеровПутей.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
		Путь = Неопределено;
		
		Пока ВыборкаПутей.Следующий() Цикл
			Если Путь = Неопределено Тогда
				Путь = ВременныйКаталог + "\" + ОбщегоНазначенияКлиентСервер.ЧислоВСтроку(ВыборкаНомеровПутей.НомерПути);
			КонецЕсли;
			
			ИмяФайла = Путь + ВыборкаПутей.Путь;
			ИмяКаталога = ОбщегоНазначенияКлиентСервер.ИмяКаталога(ИмяФайла);
			СоздатьКаталог(ИмяКаталога);
			ИменаПорций = Новый Массив;
			ЗапросДанных.УстановитьПараметр("Путь", ВыборкаПутей.Путь);
			ВыборкаПозиций = ВыборкаПутей.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
			
			Пока ВыборкаПозиций.Следующий() Цикл
				ЗапросДанных.УстановитьПараметр("НомерПорции", ВыборкаПозиций.НомерПорции);
				ВыборкаДанных = ЗапросДанных.Выполнить().Выбрать();
				
				Если ВыборкаДанных.Следующий() Тогда
					Данные = ВыборкаДанных.Данные.Получить();
					
					Если ВыборкаПозиций.МаксНомерПорции > 0 Тогда
						ДлинаНомераПорции = СтрДлина(ВыборкаПозиций.МаксНомерПорции);
						НомерПорции = ОбщегоНазначенияКлиентСервер.ЧислоВСтроку(ВыборкаПозиций.НомерПорции, ДлинаНомераПорции);
						ИмяПорции = ИмяКаталога + "\" + НомерПорции + "_" + ОбщегоНазначенияКлиентСервер.ИмяФайла(ВыборкаПутей.Путь);
						ИменаПорций.Добавить(ИмяПорции);
					Иначе
						ИмяПорции = ИмяФайла;
					КонецЕсли;
					
					Данные.Записать(ИмяПорции);
				Иначе
					ВызватьИсключение СловарьКлиентСервер.Получить(
						"НеНайденыДанныеТЖ",
						ВыборкаПутей.Путь,
						ВыборкаПутей.НомерПорции);
				КонецЕсли;
			КонецЦикла;
			
			Если ИменаПорций.Количество() > 0 Тогда
				ОбъединитьФайлы(ИменаПорций, ИмяФайла);
				
				Для Каждого ИмяПорции Из ИменаПорций Цикл
					УдалитьФайлы(ИмяПорции);
				КонецЦикла;
				
				ИменаПорций.Очистить();
			КонецЕсли;
			
			Если ДетализированныеПути Тогда
				Пути.Добавить(ИмяФайла);
			КонецЕсли;
		КонецЦикла;
		
		Если Не ДетализированныеПути Тогда
			Пути.Добавить(Путь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Пути;
	
КонецФункции // ВыгрузитьДанные()

// Выгрузить структуру хранения метаданных для последующей обработки
//
// Параметры:
//  ДокументЗамер - ДокументСсылка.Замер, владелец данных замера
//
// Возвращаемое значение:
//  Структура:
//    - СУБД - ТаблицаЗначений, структура в терминах СУБД
//    - SDBL - ТаблицаЗначений, структура в терминах SDBL
//
Функция ВыгрузитьСтруктуруМетаданных(ДокументЗамер) Экспорт
	
	Перем Метаданные;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДокументЗамер", ДокументЗамер);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	СУБД,
		|	SDBL
		|ИЗ
		|	РегистрСведений.ДанныеМетаданных
		|ГДЕ
		|	Регистратор = &ДокументЗамер";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Метаданные = Новый Структура;
		Метаданные.Вставить("СУБД", Выборка.СУБД.Получить());
		Метаданные.Вставить("SDBL", Выборка.SDBL.Получить());
	КонецЕсли;
	
	Возврат Метаданные;
	
КонецФункции // ВыгрузитьСтруктуруМетаданных()


///////////////////////////////////////////////////////////////////////////////
// СТРУКТУРЫ ДАННЫХ

// Создать структуру параметров анализа
//
// Возвращаемое значение:
//  Структура - ДокументЗамер, анализируемый замер
//
Функция СоздатьКонтекстАнализа(ДокументЗамер) Экспорт
	
	КонтекстАнализа = Новый Структура;
	КонтекстАнализа.Вставить("Замер", ДокументЗамер);
	КонтекстАнализа.Вставить("СтруктураБазы", ВыгрузитьСтруктуруМетаданных(ДокументЗамер));
	КонтекстАнализа.Вставить("СловарьШаблонов", СтруктураМетаданных.ПолучитьСловарьШаблоновМетаданных(КонтекстАнализа.СтруктураБазы.СУБД));
	
	Возврат КонтекстАнализа;
	
КонецФункции // СоздатьКонтекстАнализа()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция ПолучитьШаблонОписанияВзаимоблокировки() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Дата", Неопределено);
	Результат.Вставить("ИнформационнаяБаза", Неопределено);
	Результат.Вставить("Граф", Неопределено);
	Результат.Вставить("МоментВремени", Неопределено);
	Результат.Вставить("СвойствоПроцесса", СоздатьТаблицуСвойствПроцесса());
	Результат.Вставить("ЗапросПроцесса", СоздатьТаблицуЗапросовПроцессов());
	Результат.Вставить("Блокировки", СоздатьТаблицуБлокировок());
	Результат.Вставить("Процесс", СоздатьТаблицуПроцессов());
	Результат.Вставить("НедостаточноДанных", Ложь);
	Результат.Вставить("Проанализирована", Ложь);
	Результат.Вставить("НомерВзаимоблокировки");
	Результат.Вставить("ТипБлокировки");
	
	Возврат Результат;
	
КонецФункции // ПолучитьШаблонОписанияВзаимоблокировки()

// Создать таблицу свойств процесса
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция СоздатьТаблицуСвойствПроцесса()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерПроцесса");
	Таблица.Колонки.Добавить("Свойство");
	Таблица.Колонки.Добавить("Значение");
	Возврат Таблица;
	
КонецФункции // СоздатьТаблицуСвойствПроцесса()

// Создать таблицу запросов процессов
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция СоздатьТаблицуЗапросовПроцессов()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерПроцесса");
	// Оригинальный фрагмент запроса
	Таблица.Колонки.Добавить("ФрагментЗапроса");
	// Фрагмент запроса в котором параметры типа @P заменены на параметры типа ?
	Таблица.Колонки.Добавить("ФрагментЗапросаМодифицированный");
	Таблица.Колонки.Добавить("ФрагментЗапросаГрафа");
	Возврат Таблица;
	
КонецФункции // СоздатьТаблицуЗапросовПроцессов()

// Создать таблицу данных блокировки
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция СоздатьТаблицуБлокировок()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Процесс");
	Таблица.Колонки.Добавить("Блокировка");
	Таблица.Колонки.Добавить("Временная");
	Возврат Таблица;
	
КонецФункции // СоздатьТаблицуДанныхБлокировки()

// Создать таблицу процессов
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция СоздатьТаблицуПроцессов()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Имя");
	Таблица.Колонки.Добавить("Номер");
	Возврат Таблица;
	
КонецФункции // СоздатьТаблицуПроцессов()

// Создать структуру описания блокировки
//
// Возвращаемое значение:
//  Структура
//
Функция СоздатьОписаниеБлокировки() Экспорт
	
	Описание = Новый Структура;
	Описание.Вставить("Запрос");
	Описание.Вставить("ТекстSdbl");
	Описание.Вставить("План");
	Описание.Вставить("КонтекстЗапроса");
	Описание.Вставить("КонтекстВыполнения");
	Описание.Вставить("ВремяВыполненияМс");
	Описание.Вставить("МоментВремениОкончания");
	Описание.Вставить("ДатаВремяСобытия");
	Описание.Вставить("Пользователь");
	Описание.Вставить("Компьютер");
	Описание.Вставить("НомерСоединения");
	Описание.Вставить("Ресурс");
	Описание.Вставить("ИдентификаторРесурса");
	Описание.Вставить("Состояние");
	Описание.Вставить("Режим");
	Описание.Вставить("Гранулярность");
	Описание.Вставить("НачалоВыполненияЗапроса");
	Описание.Вставить("ИдентификаторПроцессаСУБД");
	Описание.Вставить("БлокирующийПроцесс");
	Описание.Вставить("ТипВыполнения");
	Описание.Вставить("ОбъемНеосвобожденнойПамяти");
	Описание.Вставить("МаксимальныйРасходПамяти");
	Описание.Вставить("СчитаноДанных");
	Описание.Вставить("ЗаписаноДанных");
	
	Возврат Описание;
	
КонецФункции // СоздатьОписаниеБлокировки()


///////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ

// Служебная процедура, необходимая для корректного прохождения
// проверки "Поиск неиспользуемых процедур и функций"
//
// Параметры:
//  Нет
//
Процедура ВызовыНеявноИспользуемыхПроцедурИФункций()
	
	Если Ложь Тогда
		
		ПоместитьКаталогВРегистр(Неопределено, Неопределено);
		
		ВызовыНеявноИспользуемыхПроцедурИФункций();
		
	КонецЕсли;
	
КонецПроцедуры // ВызовыНеявноИспользуемыхПроцедурИФункций()
