
#Область ПрограммныйИнтерфейс

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ БСП

// Сравнивает элементы списков значений или массивов по значениям.
//
// Параметры:
//  Список1 - Массив, СписокЗначений - сравниваемая коллекция элементов.
//  Список2 - Массив, СписокЗначений - сравниваемая коллекция элементов.
//
// Возвращаемое значение:
//  Булево - Истина, если идентичны.
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции

// Процедура управляет состояние поля табличного документа.
//
// Параметры:
//  ПолеТабличногоДокумента - ПолеФормы - поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               - Строка - задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает Истина, если клиентское приложение запущено под управлением ОС Windows.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоWindowsКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоWindowsКлиент = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ЭтоWindowsКлиент");
	
	Если ЭтоWindowsКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоWindowsКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
#КонецЕсли
	
	Возврат ЭтоWindowsКлиент;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ БСП

// Получает ссылку предопределенного элемента по его полному имени.
// Предопределенные элементы могут содержаться только в следующих объектах:
//   - Справочники;
//   - Планы видов характеристик;
//   - Планы счетов;
//   - Планы видов расчета.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - Полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение().
//     Например:
//       "Справочник.ВидыКонтактнойИнформации.EmailПользователя"
//       "ПланСчетов.Хозрасчетный.Материалы"
//       "ПланВидовРасчета.Начисления.ОплатаПоОкладу".
//
// Возвращаемое значение: 
//   ЛюбаяСсылка - ссылка на предопределенный элемент.
//   Неопределено - если предопределенный есть в метаданных, но не создан в ИБ.
//
Функция ПредопределенныйЭлемент(ПолноеИмяПредопределенного) Экспорт
	
	// Используется стандартная функция платформы для получения:
	//  - пустых ссылок; 
	//  - значений перечислений;
	//  - точек маршрута бизнес-процессов.
	Если ".ПУСТАЯССЫЛКА" = ВРег(Прав(ПолноеИмяПредопределенного, 13))
		Или "ПЕРЕЧИСЛЕНИЕ." = ВРег(Лев(ПолноеИмяПредопределенного, 13)) 
		Или "БИЗНЕСПРОЦЕСС." = ВРег(Лев(ПолноеИмяПредопределенного, 14)) Тогда
		
		Возврат ПредопределенноеЗначение(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Разбор полного имени предопределенного.
	ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенного, ".");
	Если ЧастиПолногоИмени.Количество() <> 3 Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	ПолноеИмяОбъектаМетаданных = ВРег(ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1]);
	ИмяПредопределенного = ЧастиПолногоИмени[2];
	
	// В зависимости от контекста выполняется обращение к разному кэшу.
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПредопределенныеЗначения = СтандартныеПодсистемыПовтИсп.СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных);
#Иначе
	ПредопределенныеЗначения = СтандартныеПодсистемыКлиентПовтИсп.СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных);
#КонецЕсли

	// Если ошибка в имени метаданных.
	Если ПредопределенныеЗначения = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;

	// Получение результата из кэша.
	Результат = ПредопределенныеЗначения.Получить(ИмяПредопределенного);
	
	// Если предопределенного нет в метаданных.
	Если Результат = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Если предопределенный есть в метаданных, но не создан в ИБ.
	Если Результат = Null Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного)
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Предопределенное значение ""%1"" не найдено.'"), ПолноеИмяПредопределенного);
	
КонецФункции

// Выполняет поиск элемента в коллекции: списке значений или массиве.
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип("СписокЗначений") Тогда
		Если ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип("Массив") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу.
//  Платформа - ТипПлатформы - параметр устарел, больше не используется.
//
// Возвращаемое значение:
//  Строка - путь к каталогу с конечным символом-разделителем.
//
// Пример:
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\".
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\".
//  Результат = ДобавитьКонечныйРазделительПути("%APPDATA%"); // возвращает "%APPDATA%\".
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Платформа = Неопределено) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = ПолучитьРазделительПути();
	
	Если СтрЗаканчиваетсяНа(ПутьКаталога, ДобавляемыйСимвол) Тогда
		Возврат ПутьКаталога;
	Иначе 
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	КонецЕсли;
КонецФункции

#КонецОбласти

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С НОМЕРАМИ ВЕРСИИЙ

// Получить версию платформы в виде числа формата: wwwwxxxxyyyyzzzz,
// например: 0008000100130041, где первые нули опущены
//
// Возвращаемое значение:
//  Число - версия платформы
//
Функция ВерсияПлатформы() Экспорт
	
	Инфо = Новый СистемнаяИнформация;
	Версия = ВерсияВФорматеДляСравнения(Инфо.ВерсияПриложения);
	
	Возврат Версия;
	
КонецФункции // ВерсияПлатформы()

// <Описание функции>
//
// Параметры:
//  Версия  - Строка - Номер в версии в строковом формате, разделенный точками
//
// Возвращаемое значение:
//   Число   - Номер версии в числовом формате, пригодном для сравнения
//
Функция ВерсияВФорматеДляСравнения(Версия) Экспорт
	
	ЭлементыВерсии = ОбщегоНазначенияКлиентСервер.РазделитьСтроку(Версия, ".");
	
	Возврат Число(ЭлементыВерсии[0]) * 1000000000000
	      + Число(ЭлементыВерсии[1]) * 100000000
	      + Число(ЭлементыВерсии[2]) * 10000
	      + Число(ЭлементыВерсии[3]);
	
КонецФункции // ВерсияВФорматеДляСравнения()

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
//  Булево - Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт
	
	Возврат Ложь;
	
//#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
//	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска");
//#Иначе
//	ПараметрЗапускаПриложения = ПараметрЗапуска;
//#КонецЕсли
//	
//	Возврат СтрНайти(ПараметрЗапускаПриложения, "РежимОтладки") > 0;
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.СС.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ".");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра СтрокаВерсии1: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ".");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	    	НСтр("ru = 'Неправильный формат параметра СтрокаВерсии2: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Получает номер версии конфигурации без номера сборки.
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС - номер сборки, который будет удален.
// 
// Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ.
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = СтрРазделить(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// XML

// Получить строковое XML представление DOM
//
// Параметры:
//  ДокументDOM - ДокументDOM, документ для которого нужно получить представление
//
// Возвращаемое значение:
//  Строка - XML представление DOM
//
Функция ПолучитьСтрокуXMLИзDOM(ДокументDOM) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции // ПолучитьСтрокуXMLИзDOM()

// Получить DOM представление строки XML
//
// Параметры:
//  СтрокаXML - Строка, XML представление DOM
//
// Возвращаемое значение:
//  ДокументDOM - документ для которого нужно получить представление
//
Функция ПолучитьDOMИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	Построитель = Новый ПостроительDOM();
	
	Возврат Построитель.Прочитать(ЧтениеXML);
	
КонецФункции // ПолучитьDOMИзСтрокиXML()


///////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// Округлить число вверх, т.е. 1.1 до 2.0
//
// Параметры:
//  Значение - Число, округляемое значение
//
// Возвращаемое значение:
//  Число - округленное число
//
Функция ОкрВверх(Значение) Экспорт
	
	Целое = Цел(Значение);
	Возврат Целое + ?(Значение - Целое > 0, 1, 0);
	
КонецФункции // ОкрВверх()


///////////////////////////////////////////////////////////////////////////////
// ВРЕМЯ

// Разделить интервал на целые части и фрагменты
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура
//   ГодыПолные - Массив структур (Начало, Конец)
//   ГодыФрагменты - Массив структур (Начало, Конец)
//   МесяцыПолные - Массив структур (Начало, Конец)
//   МесяцыФрагменты - Массив структур (Начало, Конец)
//   ДниПолные - Массив структур (Начало, Конец)
//   ДниФрагменты - Массив структур (Начало, Конец)
//   ЧасыПолные - Массив структур (Начало, Конец)
//   ЧасыФрагменты - Массив структур (Начало, Конец)
//   МинутыПолные - Массив структур (Начало, Конец)
//   МинутыФрагменты - Массив структур (Начало, Конец)
//
Функция РазделитьИнтервал(Начало, Конец) Экспорт
	
	Интервалы = Новый Структура;
	Интервалы.Вставить("ГодыПолные", Новый Массив);
	Интервалы.Вставить("ГодыФрагменты", Новый Массив);
	Интервалы.Вставить("МесяцыПолные", Новый Массив);
	Интервалы.Вставить("МесяцыФрагменты", Новый Массив);
	Интервалы.Вставить("ДниПолные", Новый Массив);
	Интервалы.Вставить("ДниФрагменты", Новый Массив);
	Интервалы.Вставить("ЧасыПолные", Новый Массив);
	Интервалы.Вставить("ЧасыФрагменты", Новый Массив);
	Интервалы.Вставить("МинутыПолные", Новый Массив);
	Интервалы.Вставить("МинутыФрагменты", Новый Массив);
	
	Годы = РазделитьГоды(Начало, Конец);
	ДобавитьВМассив(Интервалы.ГодыПолные, Годы.Полные);
	ДобавитьВМассив(Интервалы.ГодыФрагменты, Годы.Фрагменты);
	
	Для каждого Фрагмент Из Интервалы.ГодыФрагменты Цикл
		Месяцы = РазделитьМесяцы(Фрагмент.Начало, Фрагмент.Конец);
		ДобавитьВМассив(Интервалы.МесяцыПолные, Месяцы.Полные);
		ДобавитьВМассив(Интервалы.МесяцыФрагменты, Месяцы.Фрагменты);
	КонецЦикла;
	
	Для каждого Фрагмент Из Интервалы.МесяцыФрагменты Цикл
		Дни = РазделитьДни(Фрагмент.Начало, Фрагмент.Конец);
		ДобавитьВМассив(Интервалы.ДниПолные, Дни.Полные);
		ДобавитьВМассив(Интервалы.ДниФрагменты, Дни.Фрагменты);
	КонецЦикла;
	
	Для каждого Фрагмент Из Интервалы.ДниФрагменты Цикл
		Часы = РазделитьЧасы(Фрагмент.Начало, Фрагмент.Конец);
		ДобавитьВМассив(Интервалы.ЧасыПолные, Часы.Полные);
		ДобавитьВМассив(Интервалы.ЧасыФрагменты, Часы.Фрагменты);
	КонецЦикла;
	
	Для каждого Фрагмент Из Интервалы.ЧасыФрагменты Цикл
		Минуты = РазделитьМинуты(Фрагмент.Начало, Фрагмент.Конец);
		ДобавитьВМассив(Интервалы.МинутыПолные, Минуты.Полные);
		ДобавитьВМассив(Интервалы.МинутыФрагменты, Минуты.Фрагменты);
	КонецЦикла;
	
	Возврат Интервалы;
	
КонецФункции // РазделитьИнтервал()

// Добавить элементы одного массива к элементам другого массива
//
// Параметры:
//  Приемник - Массив, в которые будут добавлены элементы из Источник
//  Источник - Массив, из которого элементы будут скопированы в Приемник
//
Процедура ДобавитьВМассив(Приемник, Источник)
	
	Для каждого Элемент Из Источник Цикл
		Приемник.Добавить(Элемент);
	КонецЦикла;
	
КонецПроцедуры // ДобавитьВМассив()

// Создать структуру интервала
//
// Параметры:
//  Начало - Дата или Число, начало интервала
//  Конец - Дата или Число, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата или Число, начало интервала
//  * Конец - Дата или Число, конец интервала
//
Функция НовыйИнтервал(Начало = Неопределено, Конец = Неопределено)
	
	Интервал = Новый Структура("Начало, Конец");
	Интервал.Начало = Начало;
	Интервал.Конец = Конец;
	Возврат Интервал;
	
КонецФункции // НовыйИнтервал()

// Создать набор полных интервалов и фрагментов интервалов
//
// Возвращаемое значение:
//  Структура:
//  * Полные - Массив, полные интервалы
//  * Фрагменты - Массив, фрагменты интервалов
//
Функция НовыйНаборИнтервалов()
	
	НаборИнтервалов = Новый Структура(
		"Полные, Фрагменты",
		Новый Массив,
		Новый Массив);
	Возврат НаборИнтервалов;
	
КонецФункции // НовыйНаборИнтервалов()

// Определить начало целого периода
//
// Параметры:
//  Начало - Дата, начало периода
//  Конец - Дата, конец периода
//  НачалоЧего - Строка, (например: "Года", получится в итоге НачалоГода()
//
// Возвращаемое значение:
//  Дата - начало целой части периода или Неопрелено, если нет целой части
//
Функция ОпредлитьНачалоЦелогоПериода(Начало, Конец, НачалоЧего)
	
	НачалоПериода = Вычислить("Начало" + НачалоЧего + "(Начало)");
	КонецПериода = Вычислить("Конец" + НачалоЧего + "(Начало)");
	
	Если Начало = НачалоПериода Тогда
		ДатаНачала = НачалоПериода;
	ИначеЕсли Конец > КонецПериода Тогда
		ДатаНачала = КонецПериода + 1;
	Иначе
		ДатаНачала = Неопределено;
	КонецЕсли;
	
	Возврат ДатаНачала;
	
КонецФункции // ОпредлитьНачалоЦелогоПериода()

// Определить окнец целого периода
//
// Параметры:
//  Начало - Дата, начало периода
//  Конец - Дата, конец периода
//  КонецЧего - Строка, (например: "Года", получится в итоге КонецГода()
//
// Возвращаемое значение:
//  Дата - конец целой части периода или Неопрелено, если нет целой части
//
Функция ОпредлитьКонецЦелогоПериода(Начало, Конец, КонецЧего)
	
	КонецПериода = Вычислить("Конец" + КонецЧего + "(Конец)");
	НачалоПериода = Вычислить("Начало" + КонецЧего + "(Конец)");
	
	Если Конец = КонецПериода Тогда
		ДатаКонца = КонецПериода;
	ИначеЕсли Начало < НачалоПериода Тогда
		ДатаКонца = НачалоПериода - 1;
	Иначе
		ДатаКонца = Неопределено;
	КонецЕсли;
	
	Возврат ДатаКонца;
	
КонецФункции // ОпредлитьКонецЦелогоПериода()

// Определить, есть ли целые части интервалов
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Булево - Истина, если есть целые части интервала
//
Функция ЕстьЦелыеИнтервалы(Начало, Конец)
	
	Возврат Начало <> Неопределено И Конец <> Неопределено И Начало < Конец;
	
КонецФункции // ЕстьЦелыеИнтервалы()

// Получить фрагменты интервалов
//
// Параметры:
//  Начало - Дата, дата начала основного интервала
//  Конец - Дата, дата конца основного интервала
//  Тип - Строка, (например: "Года", получится в итоге НачалоГода()
//
Функция ПолучитьФрагментыИнтервалов(Начало, Конец, Тип, ТипВыше, ЕдиницаВыше)
	
	ДатаНачала = ОпредлитьНачалоЦелогоПериода(Начало, Конец, Тип);
	ДатаКонца = ОпредлитьКонецЦелогоПериода(Начало, Конец, Тип);
	ЕстьЦелые = ЕстьЦелыеИнтервалы(ДатаНачала, ДатаКонца);
	НаборИнтервалов = НовыйНаборИнтервалов();
	
	Если ЕстьЦелые Тогда
		Если Начало <> ДатаНачала Тогда
			ИнтервалНачала = НовыйИнтервал(Начало, ДатаНачала - 1);
			НаборИнтервалов.Фрагменты.Добавить(ИнтервалНачала);
		КонецЕсли;
		
		Если Конец <> ДатаКонца Тогда
			ИнтервалКонца = НовыйИнтервал(ДатаКонца + 1, Конец);
			НаборИнтервалов.Фрагменты.Добавить(ИнтервалКонца);
		КонецЕсли;
	Иначе
		ИнтервалКонца = НовыйИнтервал(Начало, Конец);
		НаборИнтервалов.Фрагменты.Добавить(ИнтервалКонца);
	КонецЕсли;
	
	Если ЕстьЦелые Тогда
		Если ВРег(Тип) = "ГОДА" Тогда
			Полные = НовыйИнтервал(ДатаНачала, ДатаКонца);
			НаборИнтервалов.Полные.Добавить(Полные);
		Иначе
			Если Вычислить(ЕдиницаВыше + "(ДатаНачала)") <> Вычислить(ЕдиницаВыше + "(ДатаКонца)") Тогда
				Полные = НовыйИнтервал(ДатаНачала, Вычислить("Конец" + ТипВыше + "(ДатаНачала)"));
				НаборИнтервалов.Полные.Добавить(Полные);
				Полные = НовыйИнтервал(Вычислить("Начало" + ТипВыше + "(ДатаКонца)"), ДатаКонца);
				НаборИнтервалов.Полные.Добавить(Полные);
			Иначе
				Полные = НовыйИнтервал(ДатаНачала, ДатаКонца);
				НаборИнтервалов.Полные.Добавить(Полные);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НаборИнтервалов;
	
КонецФункции // ПолучитьФрагментыИнтервалов()

// Разделить года на целые и дробные части
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата, начало интервала целых лет
//  * Конец - Дата, конец интервала целых лет
//  * Фрагменты - Массив структур типа:
//    * Начало - Дата, начало неполного интервала
//    * Конец - Дата, конец неполного интервала
//
Функция РазделитьГоды(Начало, Конец)
	
	Возврат ПолучитьФрагментыИнтервалов(Начало, Конец, "Года", "", "");
	
КонецФункции // РазделитьГоды()

// Разделить месяцы на целые и дробные части
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата, начало интервала целых месяцев
//  * Конец - Дата, конец интервала целых месяцев
//  * Фрагменты - Массив структур типа:
//    * Начало - Дата, начало неполного интервала
//    * Конец - Дата, конец неполного интервала
//
Функция РазделитьМесяцы(Начало, Конец)
	
	Возврат ПолучитьФрагментыИнтервалов(Начало, Конец, "Месяца", "Года", "Год");
	
КонецФункции // РазделитьМесяцы()

// Разделить дни на целые и дробные части
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата, начало интервала целых дней
//  * Конец - Дата, конец интервала целых дней
//  * Фрагменты - Массив структур типа:
//    * Начало - Дата, начало неполного интервала
//    * Конец - Дата, конец неполного интервала
//
Функция РазделитьДни(Начало, Конец)
	
	Возврат ПолучитьФрагментыИнтервалов(Начало, Конец, "Дня", "Месяца", "Месяц");
	
КонецФункции // РазделитьДни()

// Разделить часы на целые и дробные части
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата, начало интервала целых часов
//  * Конец - Дата, конец интервала целых часов
//  * Фрагменты - Массив структур типа:
//    * Начало - Дата, начало неполного интервала
//    * Конец - Дата, конец неполного интервала
//
Функция РазделитьЧасы(Начало, Конец)
	
	Возврат ПолучитьФрагментыИнтервалов(Начало, Конец, "Часа", "Дня", "День");
	
КонецФункции // РазделитьЧасы()

// Разделить часы на целые и дробные части
//
// Параметры:
//  Начало - Дата, начало интервала
//  Конец - Дата, конец интервала
//
// Возвращаемое значение:
//  Структура:
//  * Начало - Дата, начало интервала целых минут
//  * Конец - Дата, конец интервала целых минут
//  * Фрагменты - Массив структур типа:
//    * Начало - Дата, начало неполного интервала
//    * Конец - Дата, конец неполного интервала
//
Функция РазделитьМинуты(Начало, Конец)
	
	Возврат ПолучитьФрагментыИнтервалов(Начало, Конец, "Минуты", "Часа", "Час");
	
КонецФункции // РазделитьМинуты()


///////////////////////////////////////////////////////////////////////////////
// ФОРМАТИРОВАНИЕ

// Получить строку длительности
//
// Параметры:
//  Длительность - Число, длительность в секундах
//
// Возвращаемое значение:
//  Строка - отформатированная строка длительности
//
Функция ДлительностьВСтроку(Знач Длительность) Экспорт
	
	Результат = "";
	
	Дни = Цел(Длительность / 86400);
	Длительность = Длительность - Дни * 86400;
	Часы = Цел(Длительность / 3600);
	Длительность = Длительность - Часы * 3600;
	Минуты = Цел(Длительность / 60);
	Длительность = Длительность - Минуты * 60;
	Секунды = Длительность;
	
	Результат = ?(Дни > 0, Результат + Дни + " дн.", "");
	Результат = ?(Часы > 0, Результат + ?(СтрДлина(Результат)> 0, " ", "") + Часы + " ч.", Результат);
	Результат = ?(Минуты > 0, Результат + ?(СтрДлина(Результат)> 0, " ", "") + Минуты + " м.", Результат);
	Результат = ?(Секунды > 0, Результат + ?(СтрДлина(Секунды)> 0, " ", "") + Секунды + " с.", Результат);
	
	Возврат Результат;
	
КонецФункции // ДлительностьВСтроку()

// Разделить строку на составляющие по разделителю и поместить
// части строки в массив
//
// Параметры:
//  РазделяемаяСтрока - Строка, которую нужно разделить
//  Разделитель - Строка, символ разделяющий части строки
//  ПустыеСтроки - Булево, Истина - включать пустые строки в результат,
//                 Ложь - не включать пустые строки в результат
//  Сокращать - Булево, Истина - делать СокрЛП результату, Ложь - нет.
//
// Возвращаемое значение:
//  Массив - части строк
//
Функция РазделитьСтроку(ИсходнаяСтрока, Разделитель, ПустыеСтроки = Ложь, Сокращать = Истина) Экспорт
	
	Результат = СтрРазделить(ИсходнаяСтрока, Разделитель, ПустыеСтроки);
	Если Сокращать Или Не ПустыеСтроки Тогда
		ВГраница = Результат.ВГраница();
		Для Сч = 0 По ВГраница Цикл
			Индекс = ВГраница - Сч;
			Если Сокращать Тогда
				Результат[Индекс] = СокрЛП(Результат[Индекс]);
			КонецЕсли;
			Если Не ПустыеСтроки Тогда
				Если Не ЗначениеЗаполнено(Результат[Индекс]) Тогда
					Результат.Удалить(Индекс);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // РазделитьСтроку()

// Объединить строку из массива
// части строки в массив
//
// Параметры:
//  МассивСтрок - Строка, строки, которые нужно объединить
//  Разделитель - Строка, символ разделяющий части строки
//
// Возвращаемое значение:
//  Строка - объединенная строка
//
Функция ОбъединитьСтроку(МассивСтрок, Разделитель) Экспорт
	
	Результат = СтрСоединить(МассивСтрок, Разделитель);
	
	Возврат Результат;
	
КонецФункции // ОбъединитьСтроку()

// Получить количество общее количество секунд в дате
//
// Параметры:
//  ЗначениеДаты - Дата, исходное значение даты
//
// Возвращаемое значение:
//  Число - общее количество секунд в дате
//
Функция ПреобразоватьДатуВСекунды(ЗначениеДаты) Экспорт
	
	Возврат ЗначениеДаты - '00010101';
	
КонецФункции // ПреобразоватьДатуВСекунды()

// Сократить строку до указанной длины
//
// Параметры:
//  ИсходнаяСтрока - Строка
//  Длина - Число, максимальная длина строки
//
Функция СократитьСтроку(ИсходнаяСтрока, Длина) Экспорт
	
	ДлинаИсходнойСтроки = СтрДлина(ИсходнаяСтрока);
	
	Если ДлинаИсходнойСтроки > Длина Тогда
		Возврат Лев(ИсходнаяСтрока, Длина - 3) + "...";
	Иначе
		Возврат ИсходнаяСтрока;
	КонецЕсли;
	
КонецФункции // СократитьСтроку()

// Дополнить начало или конец строки указанным количеством повторений подстроки
//
// Параметры:
//  Строка - Строка, исходная строка
//  Символ - Строка, добавляемый символ
//  Длина - Число, максимальная длина результирующей строки
//  Позиция - Булево, позиция добавления подстроки.
//            Истина - в начало. Ложь - в конец.
//
// Возвращаемое значение:
//  Строка - результат добавления строки
//
Функция ДополнитьСтроку(Строка, Символ, Длина = 1, Позиция = Истина) Экспорт
	
	Подстрока = "";
	ДлинаСтроки = СтрДлина(Строка) + 1;
	
	Для Сч = ДлинаСтроки По Длина Цикл
		Подстрока = Подстрока + Символ;
	КонецЦикла;
	
	Если Позиция = Истина Тогда
		Возврат Подстрока + Строка;
	Иначе
		Возврат Строка + Подстрока;
	КонецЕсли;
	
КонецФункции // ДобавитьЛидирующиеНули()

// Преобразовать число в строку без групп
//
// Параметры:
//  Число - Число, которое нужно преобразовать
//  ЛидирующихНулей - Число, длина результирующего числа, до которой нужно
//                 расширить нулями исходное число
//
// Возвращаемое значение:
Функция ЧислоВСтроку(Число, ЛидирующихНулей = 0) Экспорт
	
	ЧислоВСтроке = Формат(Число, "ЧН=0; ЧГ=0");
	
	Если ЛидирующихНулей > 0 Тогда
		ДлинаЧисла = СтрДлина(ЧислоВСтроке);
		
		Для Сч = ДлинаЧисла По ЛидирующихНулей - 1 Цикл
			ЧислоВСтроке = "0" + ЧислоВСтроке;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ЧислоВСтроке;
	
КонецФункции // ЧислоВСтроку()

// Преобразовать строку в число и при невозможности преобразования,
// установить значение по-умолчанию
//
// Параметры:
//  Строка - Строка, содержащая число
//  ЗначениеПоУмолчанию - Число, значение, которое будет возвращено,
//                 если не удастся преобразовать строку в число
//
// Возвращаемое значение:
//  Число - результат преобразования
//
Функция СтрокуВЧисло(Строка, ЗначениеПоУмолчанию = 0) Экспорт
	
	Попытка
		Возврат Число(Строка);
	Исключение
		Возврат ЗначениеПоУмолчанию;
	КонецПопытки;
	
КонецФункции // СтрокуВЧисло()

// Поиск числа в строке
//
// Параметры:
//  ИсходнаяСтрока - Строка, строка в которой ищется число
//  ПозицияЧисла - Число, позиция начала числа
//  КоличествоСимволов - Число, количество символов числа
//
// Возвращаемое значение:
//  Булево - Истина, число найдено
//
Функция НайтиЧислоВСтроке(ИсходнаяСтрока, ПозицияЧисла, КоличествоСимволов) Экспорт
	
	ПозицияЧисла = 0;
	КоличествоСимволов = 0;
	ДлинаСтроки = СтрДлина(ИсходнаяСтрока);
	
	Для Сч = 1 По ДлинаСтроки Цикл
		
		ТекущийСимвол = КодСимвола(Сред(ИсходнаяСтрока, Сч, 1));
		
		Если 48 <= ТекущийСимвол И ТекущийСимвол <= 57 Тогда
			
			Если ПозицияЧисла = 0 Тогда
				
				ПозицияЧисла = Сч;
				КоличествоСимволов = 1;
				
			Иначе
				КоличествоСимволов = КоличествоСимволов + 1;
			КонецЕсли;
		Иначе
			Если ПозицияЧисла <> 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПозицияЧисла > 0;
	
КонецФункции // НайтиЧислоВСтроке()

// Преобразовать массив параметров в строку
//
// Параметры:
//  Параметры - Массив, параметров
//
// Возвращаемое значение:
//  Строка, параметры в виде строки
//
Функция ПараметрыВСтроку(Параметры) Экспорт
	
	СписокПараметров = "";
	НомерПараметра = 0;
	
	Если Параметры <> Неопределено Тогда
		Для Каждого Параметр Из Параметры Цикл
			Если Не ПустаяСтрока(СписокПараметров) Тогда
				СписокПараметров = СписокПараметров + ", ";
			КонецЕсли;
			
			Индекс = Формат(НомерПараметра, "ЧН=0; ЧГ=0");
			СписокПараметров = СписокПараметров + "Параметры[" + Индекс + "]";
			НомерПараметра = НомерПараметра + 1;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокПараметров;
	
КонецФункции // ПараметрыВСтроку()

// Удалить ограничивающие строку кавычки
//
// Параметры:
//  ИсходнаяСтрока - Строка, для которой нужно удалить кавычки
//
// Возвращаемое значение:
//  Строка - строка без ограничивающих ее кавычек
//
Функция УдалитьКавычки(ИсходнаяСтрока) Экспорт
	
	Результат = СокрЛП(ИсходнаяСтрока);
	
	Если Лев(Результат, 1) <> """" Или Прав(Результат, 1) <> """" Тогда
		Возврат Результат;
	КонецЕсли;
	
	Возврат Сред(Результат, 2, СтрДлина(Результат) - 2);
	
КонецФункции // УдалитьКавычки()

#Если Сервер Тогда
// Зашифровать пароль
// используя алгоритм обратимого шифрования
//
// Параметры:
//  Пароль - Строка, шифруемый пароль
//
// Возвращаемое значение:
//  Строка - обратимо зашифрованный пароль
//
Функция ЗашифроватьПароль(Пароль) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	Запись = Новый ЗаписьТекста(ИмяВременногоФайла);
	Запись.Записать(Пароль);
	Запись.Закрыть();
	ДанныеПароля = Новый ДвоичныеДанные(ИмяВременногоФайла);
	ЗашифрованныйПароль = Base64Строка(ДанныеПароля);
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат ЗашифрованныйПароль;
	
КонецФункции // ЗашифроватьПароль()

// Расшифровать пароль
// используя алгоритм обратимого шифрования
//
// Параметры:
//  Пароль - Строка, расшифровываемый пароль
//
// Возвращаемое значение:
//  Строка - расшифрованный пароль
//
Функция РасшифроватьПароль(Пароль) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДанныеПароля = Base64Значение(Пароль);
	ДанныеПароля.Записать(ИмяВременногоФайла);
	Чтение = Новый ЧтениеТекста(ИмяВременногоФайла);
	РасшифрованныйПароль = Чтение.Прочитать();
	Чтение.Закрыть();
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат РасшифрованныйПароль;
	
КонецФункции // РасшифроватьПароль()

#КонецЕсли

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// ФАЙЛОВАЯ СИСТЕМА
//

// Получить символ разделителя пути в зависимости от типа ОС
//
// Возвращаемое значение:
//  Строка - Символ разделяющий элементы пути
//
Функция РазделительПути() Экспорт
	
	Возврат ?(ТипОС() = ПредопределенноеЗначение("Перечисление.ТипыОС.Windows"), "\", "/");
	
КонецФункции // РазделительПути()

// Проверить путь на наличие завершающего слеша и если он есть, удалить его
//
// Параметры:
//  Путь - Строка, путь
//
// Возвращаемое значение:
//  Путь - Строка, обработанный путь
//
Функция СкорректироватьПуть(Путь) Экспорт
	
	Перем Разделитель;
	
	ДлинаПути = СтрДлина(Путь);
	
	Если ДлинаПути = 0 Тогда
		Возврат Путь;
	КонецЕсли;
	
	Если СтрНайти(Путь, "/") <> 0 Тогда
		Разделитель = "/";
	ИначеЕсли СтрНайти(Путь, "\") <> 0 Тогда
		Разделитель = "\";
	Иначе
		Возврат Путь;
	КонецЕсли;
	
	Пока ДлинаПути > 0 И Прав(Путь, 1) = Разделитель Цикл
		Путь = Лев(Путь, ДлинаПути - 1);
		ДлинаПути = СтрДлина(Путь);
	КонецЦикла;
	
	Возврат Путь;
	
КонецФункции // СкорректироватьПуть()

// Получить имя файла из имени пути
//
// Параметры:
//  Путь - Строка, полный путь
//
// Возвращаемое значение:
//  Строка - имя каталога
//
Функция ИмяФайла(Путь) Экспорт
	
	Длина = СтрДлина(Путь);
	Позиция = Длина;
	
	Пока Позиция > 0 Цикл
		
		ТекущийСимвол = Сред(Путь, Позиция, 1);
		
		Если ТекущийСимвол = "/" Или ТекущийСимвол = "\" Тогда
			Возврат Прав(Путь, Длина - Позиция);
		КонецЕсли;
		
		Позиция = Позиция - 1;
		
	КонецЦикла;
	
	Возврат Путь;
	
КонецФункции // ИмяФайла()

// Получить имя каталога из имени пути
//
// Параметры:
//  Путь - Строка, полный путь
//
// Возвращаемое значение:
//  Строка - имя каталога
//
Функция ИмяКаталога(Путь) Экспорт
	
	Позиция = СтрДлина(Путь);
	
	Пока Позиция > 0 Цикл
		
		ТекущийСимвол = Сред(Путь, Позиция, 1);
		
		Если ТекущийСимвол = "/" Или ТекущийСимвол = "\" Тогда
			Возврат Лев(Путь, Позиция - 1);
		КонецЕсли;
		
		Позиция = Позиция - 1;
		
	КонецЦикла;
	
	Возврат Путь;
	
КонецФункции // ИмяКаталога()

// Получить имя файла по указанному времени
//
// Параметры:
//  Время - ДатаВремя
//
// Возвращаемое значение:
//  Строка - Имя файла
//
Функция ИмяФайлаПоВремени(Время) Экспорт
	
	Возврат Формат(Время, "ДФ=""гггг-ММ-дд ЧЧ-мм-сс""");
	
КонецФункции // ИмяФайлаПоВремени()

// Получить имя файла настройки технологического журнала
//
// Параметры:
//  КаталогНастройкиТЖ - Строка, каталог размещения logcfg.xml
//
// Возвращаемое значение:
//  Строка - полное имя logcfg.xml
//
Функция ПолучитьИмяФайлаНастройкиТЖ(КаталогНастройкиТЖ) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.СкорректироватьПуть(КаталогНастройкиТЖ) + "/logcfg.xml";
	
КонецФункции // ПолучитьИмяФайлаНастройкиТЖ()


///////////////////////////////////////////////////////////////////////////////
// РЕКВИЗИТЫ

// Проверить заполнение указанных реквизитов
//
// Параметры:
//  Объект - объект содержащий реквизиты
//  Реквизиты - Строка, реквизиты перечисленные через запятую
//
// Возвращаемое значение:
//  Строка - имя незаполненного реквизита, Неопределено, если все заполнены
//
Функция НайтиНезаполненныйРеквизит(Объект, Реквизиты) Экспорт
	
	Реквизиты = ОбщегоНазначенияКлиентСервер.РазделитьСтроку(Реквизиты, ",");
	
	Для Каждого Реквизит Из Реквизиты Цикл
		Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
			Возврат Реквизит;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиНезаполненныйРеквизит()

// Получить синоним реквизита указанного объекта
//
// Параметры:
//  Реквизиты - КоллекцияОбъектовМетаданных, объект содержащий реквизит
//  Реквизит - Строка, имя реквизита
//
// Возвращаемое значение:
//  Строка - синоним реквизита или имя реквизита, если он не найден
//
Функция СинонимРеквизита(Реквизиты, Реквизит) Экспорт
	
	Если Реквизиты.Найти(Реквизит) <> Неопределено Тогда
		Возврат Реквизиты[Реквизит].Синоним;
	Иначе
		Возврат Реквизит;
	КонецЕсли;
	
КонецФункции // СинонимРеквизита()


///////////////////////////////////////////////////////////////////////////////
// ОПЕРАЦИОННАЯ СИСТЕМА

// Определить тип операционной системы на котором выполняется код
//
// Возвращаемое значение:
//  Перечисления.ТипОС - тип операционной системы
//
Функция ТипОС() Экспорт
	
	Информация = Новый СистемнаяИнформация;
	ВерсияОС = Информация.ВерсияОС;
	
	Если СтрНайти(ВРег(ВерсияОС), "WINDOWS") <> 0 Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыОС.Windows");
	Иначе
		Возврат ПредопределенноеЗначение("Перечисление.ТипыОС.Linux");
	КонецЕсли;
	
КонецФункции // ТипОС()

// Получить знечение системной переменной окружения по ее имени
//
// Параметры:
//  ИмяПременной - Строка, имя переменной окружения
//
// Возвращаемое значение:
// Строка - значение переменной окружения
//
Функция ЗначениеСистемнойПеременнойОкружения(ИмяПременной) Экспорт
	
	Возврат ЗначениеПеременнойОкружения(ИмяПременной, "System");
	
КонецФункции // ЗначениеСистемнойПеременнойОкружения()

// Получить знечение пользовательской переменной окружения по ее имени
//
// Параметры:
//  ИмяПременной - Строка, имя переменной окружения
//
// Возвращаемое значение:
// Строка - значение переменной окружения
//
Функция ЗначениеПользовательскойПеременнойОкружения(ИмяПременной) Экспорт
	
	Возврат ЗначениеПеременнойОкружения(ИмяПременной, "User");
	
КонецФункции // ЗначениеПользовательскойПеременнойОкружения()

// Получить знечение дополнительной переменной окружения по ее имени
//
// Параметры:
//  ИмяПременной - Строка, имя переменной окружения
//
// Возвращаемое значение:
// Строка - значение переменной окружения
//
Функция ЗначениеДополнительнойПеременнойОкружения(ИмяПременной) Экспорт
	
	Возврат ЗначениеПеременнойОкружения(ИмяПременной, "Volatile");
	
КонецФункции // ЗначениеДополнительнойПеременнойОкружения()

// Получить знечение переменной окружения процесса по ее имени
//
// Параметры:
//  ИмяПременной - Строка, имя переменной окружения
//
// Возвращаемое значение:
// Строка - значение переменной окружения
//
Функция ЗначениеПеременнойОкруженияПроцесса(ИмяПременной) Экспорт
	
	Возврат ЗначениеПеременнойОкружения(ИмяПременной, "Process");
	
КонецФункции // ЗначениеПеременнойОкруженияПроцесса()

// Получить знечение переменной окружения по ее имени и типу
//
// Параметры:
//  ИмяПременной - Строка, имя переменной окружения
//  ТипПеременной - Строка, тип переменной (System, User, Volatile, Process)
//
// Возвращаемое значение:
// Строка - значение переменной окружения
//
Функция ЗначениеПеременнойОкружения(ИмяПременной, ТипПеременной)
	
	Скрипт = Новый COMОбъект("WScript.Shell");
	Переменные = Скрипт.Environment(ТипПеременной);
	
	Для Каждого Перменная Из Переменные Цикл
		
		ПозицияРазделителя = СтрНайти(Перменная, "=");
		
		Если ПозицияРазделителя = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Если ВРег(Лев(Перменная, ПозицияРазделителя - 1)) = ВРег(ИмяПременной) Тогда
			Возврат Прав(Перменная, СтрДлина(Перменная) - ПозицияРазделителя);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // ЗначениеПеременнойОкружения()

// Функция получает имя сервера СУБД
//
// Параметры:
//  ПолноеИмяСервераСУБД - Строка, содержит имя сервера и инстанции
//
// Возвращаемое значение:
//  Строка - имя сервера СУБД
//
Функция ПолучитьИмяСервераСУБД(ПолноеИмяСервераСУБД) Экспорт
	
	// Исходное имя сервера
	ИмяСервераСУБД = ПолноеИмяСервераСУБД;
	
	// Определить омя сервера СУБД
	ПозицияРазделителяИнстанции = СтрНайти(ПолноеИмяСервераСУБД, "\");
	
	// Если инстанция присутствует в имени
	Если ПозицияРазделителяИнстанции <> 0 Тогда
		
		// Получение имени компьютера на котором расположен сервер СУБД
		ИмяСервераСУБД = Лев(ИмяСервераСУБД, ПозицияРазделителяИнстанции - 1);
		
	КонецЕсли;
	
	Возврат ИмяСервераСУБД;
	
КонецФункции // ПолучитьИмяСервераСУБД()

// Функция получает имя сервера СУБД
//
// Параметры:
//  ПолноеИмяСервераСУБД - Строка, содержит имя сервера и инстанции
//
// Возвращаемое значение:
//  Строка - имя инстанции сервера СУБД
//
Функция ПолучитьИмяИнстанцииСервераСУБД(ПолноеИмяСервераСУБД) Экспорт
	
	// Исходное имя сервера
	ИмяИнстанцииСервераСУБД = "";
	
	// Определить омя сервера СУБД
	ПозицияРазделителяИнстанции = СтрНайти(ПолноеИмяСервераСУБД, "\");
	
	// Если инстанция присутствует в имени
	Если ПозицияРазделителяИнстанции <> 0 Тогда
		
		// Получение имени компьютера на котором расположен сервер СУБД
		ИмяИнстанцииСервераСУБД = 
			Прав(ПолноеИмяСервераСУБД,
		         СтрДлина(ПолноеИмяСервераСУБД) - ПозицияРазделителяИнстанции);
		
	КонецЕсли;
	
	Возврат ИмяИнстанцииСервераСУБД;
	
КонецФункции // ПолучитьИмяИнстанцииСервераСУБД()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С МАССИВАМИ СТРУКТУР

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция НайтиЭлементМассиваСтруктур(Массив, Колонка, Значение) Экспорт
	
	Результат = Неопределено;
	Для Каждого ТекСтр Из Массив Цикл
		Если ТекСтр[Колонка] = Значение Тогда
			Результат = ТекСтр;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // НайтиЭлементМассиваСтруктур()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция НайтиСтрокуВМассивеСтруктур(ТаблицаПоказателей, Колонка, Значение) Экспорт
	
	СтрокаПоказателя = Неопределено;
	Для Каждого ТекСтрока Из ТаблицаПоказателей Цикл
		Если ТекСтрока[Колонка] = Значение Тогда
			СтрокаПоказателя = ТекСтрока;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаПоказателя;
	
КонецФункции // НайтиСтрокуВТаблицеПоказателей()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция НайтиСтрокиВМассивеСтруктур(ТаблицаПоказателей, Колонка, Значение) Экспорт
	
	Результат = Новый Массив;
	Для Каждого ТекСтрока Из ТаблицаПоказателей Цикл
		Если ТекСтрока[Колонка] = Значение Тогда
			Результат.Добавить(ТекСтрока);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // НайтиСтрокиВМассивеСтруктур()

// Суммирует значения всех строк в указанной колонке
//
Функция ИтогПоКолонкеВМассивеСтруктур(Массив, Колонка) Экспорт
	
	Результат = 0;
	Для Каждого ТекСтр Из Массив Цикл
		Результат = Результат + ТекСтр[Колонка];
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение ОценкаПроизводительностиКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'"), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура, ФиксированнаяСтруктура - Объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - Имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный. Возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - Значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Структура = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Результат = ЗначениеПоУмолчанию;
	Если Структура.Свойство(Ключ, Результат) Тогда
		Возврат Результат;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// Создает копию значения типа Структура, рекурсивно, с учетом типов значений свойств. 
// Если свойства структуры содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СтруктураИсточник - Структура - копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - объект, который необходимо 
//             скопировать.
//
// Возвращаемое значение:
//  Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Источник) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Возврат Источник.Скопировать();
	КонецЕсли;
#КонецЕсли	
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// ПРОЧЕЕ

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Экспорт
	
	Если Условие <> Истина Тогда
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + " " + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'в %1'"), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение, если тип значения параметра ИмяПараметра процедуры или функции ИмяПроцедурыИлиФункции
// отличается от ожидаемого.
// Для диагностики типов параметров, передаваемых в процедуры и функции программного интерфейса.
//
// Параметры:
//   ИмяПроцедурыИлиФункции - Строка             - имя процедуры или функции, параметр которой проверяется.
//   ИмяПараметра           - Строка             - имя проверяемого параметра процедуры или функции.
//   ЗначениеПараметра      - Произвольный       - фактическое значение параметра.
//   ОжидаемыеТипы  - ОписаниеТипов, Тип, Массив - тип(ы) параметра процедуры или функции.
//   ОжидаемыеТипыСвойств   - Структура          - если ожидаемый тип - структура, то 
//                                                 в этом параметре можно указать типы ее свойств.
//
Процедура ПроверитьПараметр(Знач ИмяПроцедурыИлиФункции, Знач ИмяПараметра, Знач ЗначениеПараметра, 
	Знач ОжидаемыеТипы, Знач ОжидаемыеТипыСвойств = Неопределено) Экспорт
	
	Контекст = "ОбщегоНазначенияКлиентСервер.ПроверитьПараметр";
	Проверить(ТипЗнч(ИмяПроцедурыИлиФункции) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
	Проверить(ТипЗнч(ИмяПараметра) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПараметра'"), Контекст);
		
	ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеПараметра, ОжидаемыеТипы);
	Проверить(ЭтоКорректныйТип <> Неопределено, 
		НСтр("ru = 'Недопустимо значение параметра ОжидаемыеТипы'"), Контекст);
		
	НедопустимыйПараметр = НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|Ожидалось: %3; передано значение: %4 (тип %5).'");
	Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимыйПараметр,
		ИмяПараметра,
		ИмяПроцедурыИлиФункции,
		ПредставлениеТипов(ОжидаемыеТипы), 
		?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр("ru = 'Неопределено'")),
		ТипЗнч(ЗначениеПараметра)));
			
	Если ТипЗнч(ЗначениеПараметра) = Тип("Структура") И ОжидаемыеТипыСвойств <> Неопределено Тогда
		
		Проверить(ТипЗнч(ОжидаемыеТипыСвойств) = Тип("Структура"), 
			НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
			
		НетСвойства = НСтр("ru = 'Недопустимое значение параметра %1 (Структура) в %2. 
			|В структуре ожидалось свойство %3 (тип %4).'");
		НедопустимоеСвойство = НСтр("ru = 'Недопустимое значение свойства %1 в параметре %2 (Структура) в %3. 
			|Ожидалось: %4; передано значение: %5 (тип %6).'");
		Для каждого Свойство Из ОжидаемыеТипыСвойств Цикл
			
			ОжидаемоеИмяСвойства = Свойство.Ключ;
			ОжидаемыйТипСвойства = Свойство.Значение;
			ЗначениеСвойства = Неопределено;
			
			Проверить(ЗначениеПараметра.Свойство(ОжидаемоеИмяСвойства, ЗначениеСвойства), 
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НетСвойства, ИмяПараметра, ИмяПроцедурыИлиФункции, ОжидаемоеИмяСвойства, ОжидаемыйТипСвойства));
				
			ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеСвойства, ОжидаемыйТипСвойства);
			Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимоеСвойство, 
				ОжидаемоеИмяСвойства,
				ИмяПараметра,
				ИмяПроцедурыИлиФункции,
				ПредставлениеТипов(ОжидаемыеТипы), 
				?(ЗначениеСвойства <> Неопределено, ЗначениеСвойства, НСтр("ru = 'Неопределено'")),
				ТипЗнч(ЗначениеСвойства)));
		КонецЦикла;
	КонецЕсли;		
	
КонецПроцедуры

Функция ПредставлениеТипов(ОжидаемыеТипы)
	Если ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Тогда
		Результат = "";
		Для Каждого Тип Из ОжидаемыеТипы Цикл
			Если Не ПустаяСтрока(Результат) Тогда
				Результат = Результат + ", ";
			КонецЕсли;
			Результат = Результат + ?(Тип = Неопределено, "Неопределено", Строка(Тип));
		КонецЦикла;
		Возврат Результат;
	Иначе
		Возврат Строка(ОжидаемыеТипы);
	КонецЕсли;
КонецФункции

Функция ЗначениеОжидаемогоТипа(Значение, ОжидаемыеТипы)
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(ОжидаемыеТипы) = Тип("ОписаниеТипов") Тогда
		Возврат ОжидаемыеТипы.Типы().Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Тип") Тогда
		Возврат ТипЗначения = ОжидаемыеТипы;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированныйМассив") Тогда
		Возврат ОжидаемыеТипы.Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Соответствие") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированноеСоответствие") Тогда
		Возврат ОжидаемыеТипы.Получить(ТипЗначения) <> Неопределено;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Ищет позицию следующего символа, который не является цифрой
//
// Параметры:
//  Строка - Строка, в которой необходимо выполнить поиск
//  НачальнаяПозиция - позиция, с которой необходимо начать поиск
//
Функция НайтиСледующуюНеЦифру(Строка, НачальнаяПозиция) Экспорт
	
	Для Сч = НачальнаяПозиция По СтрДлина(Строка) Цикл
		КодСимвола = КодСимвола(Строка, Сч);
		Если КодСимвола < 48 Или КодСимвола > 57 Тогда
			Возврат Сч;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции
